# Interop32to64BitProcess
This project is a base framework to provide communication between a 32bit process and a 64bit process. The 64bit process acts as a COM Server. We can host 64bit libs on the server and the 32bit client can use it.



Implementation : https://github.com/abhishekp314/Interop32to64BitProcess



Type: Registering COM dll into registry

1. Create a new dll project. This will be our server process.

2. Write a *runtime_routine/.reg* which registers following attributes

   ```tex
   CLSID\<GUID>\InProcServer32 = <Path_to_server_dll>
   CLSID\<GUID>\Apartment = <Threading_Model>
   CLSID\<GUID>\ProgID = <Server_ID_Name>
   ```

3. Implement the *DllRegisterServer()* and *DllUnregisterServer()* since these will be called when the dll will be loaded.

4. Make sure to add module definition file *.def* since it contains the exported symbols required by *regsvr32.exe* to register the dll methods into registry.

5. *.def* needs to be specified in the *Linker -> Input -> Module Definition file*.

6. Register it using *regsvr32.exe* from a administrator privileged cmd

   ```tex
   > regsvr32.exe <path_to_dll>
   ```

7. Build the client to load this .dll.

8. When InProcServer32 is specified, the dll is loaded inside the memory space of the client process. Thus the interop between 32 bit client and 64 bit server is not possible. Thus only 32 to 32 and 64 to 64 is possible.

9. ​Note for every change in dll, the previous dll needs to be unregistered from the registry otherwise the entries will remain there for ever. :sweat_smile: Runt he following in administrator privileged cmd

   ```tex
   > regsvr32 /u <path_to_dll>
   ```





Type: Registering COM process into registry

1. Open the server project in visual studio with administrator privileges.

2. Add and write your *.idl* file containing GUID's of the classes that needs to be queried.

3. Compile the *.idl* with the MIDL compiler standalone. A auto generated header file contains the metadata of the query classes. This classes need to be implemented. It also generates *.tlb* library which is a proxy stub that allows marshalling/unmarshalling of calls from different process environment (32/64 bit).

4. In the *WinMain()*, make sure to load the *.tlb* that is generated by the MIDL compiler.

   ```c
   int WinMain(...)
   {
     CoInitialize(0);
     
     ITypeLib* pTlb = NULL;
     HRESULT hr = LoadTypeLibEx(L"RPCComServer.tlb", REGKIND_REGISTER, &pTlb);
     
     if(FAILED(hr))
       {
         return false;
       }
     pTlb->Release();
   }
   ```

5. Build your server process.

6. Write a *.reg* file and link it to the server executable and run it, something like this

   ```
   REGEDIT
   HKEY_CLASSES_ROOT\RPCComServer\CLSID = {DC186800-657F-11D4-B0B5-0050BABFC905}
   HKEY_CLASSES_ROOT\CLSID\{DC186800-657F-11D4-B0B5-0050BABFC905} = RPCComServer
   HKEY_CLASSES_ROOT\CLSID\{DC186800-657F-11D4-B0B5-0050BABFC905}\LocalServer32 = C:\Users\abhishek.porwal\Documents\Visual Studio 2015\Projects\RPCProject\x64\Debug\RPCComServer.exe
   HKEY_CLASSES_ROOT\CLSID\{DC186800-657F-11D4-B0B5-0050BABFC905}\ThreadingModel ="Apartement"
   ```

   this registers the query classes into the registry, so that the client can get instance to this and call their methods.

7. Open the client project in visual studio with administrator privileges.

8. Build and run it. The client process should be able to communicate with server process.